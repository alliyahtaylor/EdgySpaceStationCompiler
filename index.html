<!DOCTYPE HTML>
<html>
<!--Alliyah Taylor's Compiler
//Based on "Rebecca's Bitchen Compiler Template"
//CMPT 43? - Spring 2019 -->
<head>
    <title>The edgy Space Station Compiler</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="dist/styles/compiler.css" />
    <!--<link rel="stylesheet" href="dist/styles/bootstrap.min.css"> -->
</head>
<body onload="init();">
    <h1>Deep Space: Babylon</h1>
    <hr>
    <p>. . . <em>The Last, Best Hope for Compilers</em>:</p>

    <div style="text-align:center;">
        <input type="button" id="btnCompile" value="Compile" onclick="btnCompile_click();"/>
    </div>

    <div>
        <div class="source">
            <textarea id="taSourceCode"></textarea>
            <textarea id="taOutput"></textarea>
        </div>        
    </div>

  <!--  <div>
        <img style="display:block; margin-left:auto; margin-right:auto;"
		       src="dist/images/CompilerPhases.png" 
				 alt="Compiler Phases diagram" />
    </div>   -->

    <!-- Client-side code down here, per the YSlow advice. 
         (http://developer.yahoo.com/performance/rules.html#js_bottom) -->
    <script type="text/javascript" src="dist/scripts/utils.js"></script>	
    <script type="text/javascript" src="dist/scripts/lexer.js"></script>	
    <script type="text/javascript" src="dist/scripts/globals.js"></script>	
    <script type="text/javascript">

        //Track if verbose mode is on
        let verbose = true;
        //Track if we're done with Lexical Analysis
        let endFile = false;
        //Keep track of program numbers
        let currentProg = 0;
        //Was there an error in the last program?
        let lastError = false;
        let remainder = "";

		 function init() {
	        // Clear the message box.
	        document.getElementById("taOutput").value = "";
	        // Set the initial values for our globals.
	        tokens = "";
	        tokenIndex = 0;
	        currentToken = ' ';
	        errorCount = 0;        
	    }


	    function btnCompile_click() {        
	        // This is executed as a result of the user pressing the 
	        // "compile" button between the two text areas, above.  
	        // Note the <input> element's event handler: onclick="btnCompile_click();
	        init();

	        putMessage("Lexical Analysis Started");
	        // Grab the tokens from the lexer . . .
            remainder = document.getElementById("taSourceCode").value;


              while (!endFile){
                 let LexResults = _Lexer.lex(currentProg, remainder, lastError);
                  console.log(LexResults.errors);

                 if(LexResults.errors.length != 0){
                     //If we get error, move on to next program.
                     lex(LexResults, currentProg);
                     currentProg++;
                     lastError = true;
                 } else if(LexResults.tokens.length == 0) {
                     endFile = true;
                 }else{
                     lex(LexResults, currentProg);
                     lastError = false;
                     currentProg++;
                 }

                 //if(LexResults.atEnd){
                  //   endFile = true;
                 //}



	        // . . . and parse!
	        //We're not parsing yet so don't worry about that right now.
            //parse();
	    }
		 }
    
	    function putMessage(msg) {
	        document.getElementById("taOutput").value += msg + "\n";
	    }
    
    
	 	 // TODO: These parse routines really should be in TypeScript.
		 //       This exercise is left to the read. Consider it project 0.5 .
	    function parse() {
	        putMessage("Parsing [" + tokens + "]");
	        // Grab the next token.
	        currentToken = getNextToken();
	        // A valid parse derives the G(oal) production, so begin there.
	        parseG();
	        // Report the results.
	        putMessage("Parsing found " + errorCount + " error(s).");        
	    }
    
	    function parseG() {
	        // A G(oal) production can only be an E(xpression), so parse the E production.
	        parseE();
	    }

	    function parseE() {
	        // All E productions begin with a digit, so make sure that we have one.
	        checkToken("digit");
	        // Look ahead 1 char (which is now in currentToken because checkToken 
	        // consumes another one) and see which E production to follow.
	        if (currentToken != EOF) {
	            // We're not done, we expect to have an op.
	            checkToken("op");
	            parseE();
	        } else {
	            // There is nothing else in the token stream, 
	            // and that's cool since E --> digit is valid.
	            putMessage("EOF reached");
	        }
	    }

	    function lex(LexResults, progNumber){

		     //Print out everything if we're being verbose
		     if(verbose){
                for(var i = 0; i < LexResults.tokens.length; i++){
                    putMessage("DEBUG LEXER  - " + LexResults.tokens[i].name +" [ " + LexResults.tokens[i].value + " ] found at (" + LexResults.tokens[i].lineNumber + ":" + LexResults.tokens[i].position + ")");
                }
            }
            if (LexResults.errors.length > 0){
                lastError = true;
            }

            //Print Warnings/Errors
            for(var i = 0; i < LexResults.warnings.length; i++){
               if(LexResults.warnings[i].name == "missingEOP"){
                   LexResults.tokens.push(new TSC.Token("TEOP", "$", LexResults.line, LexResults.position));
               }
                putMessage("WARNING: " + LexResults.warnings[i].name + " at (" + LexResults.warnings[i].lineNumber + ":" + LexResults.warnings[i].position + ")");
            }

            for(var i = 0; i < LexResults.errors.length; i++){
                putMessage("ERROR: " + LexResults.errors[i].name + " at (" + LexResults.errors[i].lineNumber + ":" + LexResults.errors[i].position + ")");
            }
            putMessage("Lexical Analysis Complete. " + LexResults.warnings.length + " Warning(s) and " + LexResults.errors.length + " Error(s)");

            console.log(LexResults);
            remainder = LexResults.remainder;

	    }

	    function checkToken(expectedKind) {
	        // Validate that we have the expected token kind and et the next token.
	        switch(expectedKind) {
	            case "digit":   putMessage("Expecting a digit");
	                            if (currentToken=="0" || currentToken=="1" || currentToken=="2" || 
	                                currentToken=="3" || currentToken=="4" || currentToken=="5" || 
	                                currentToken=="6" || currentToken=="7" || currentToken=="8" || 
	                                currentToken=="9")
	                            {
	                                putMessage("Got a digit!");
	                            }
	                            else
	                            {
	                                errorCount++;
	                                putMessage("NOT a digit.  Error at position " + tokenIndex + ".");
	                            }
	                            break;
	            case "op":      putMessage("Expecting an operator");
	                            if (currentToken=="+" || currentToken=="-")
	                            {
	                                putMessage("Got an operator!");
	                            }
	                            else
	                            {
	                                errorCount++;
	                                putMessage("NOT an operator.  Error at position " + tokenIndex + ".");
	                            }
	                            break;
	            default:        putMessage("Parse Error: Invalid Token Type at position " + tokenIndex + ".");
	                            break;			
	        }
	        // Consume another token, having just checked this one, because that 
	        // will allow the code to see what's coming next... a sort of "look-ahead".
	        currentToken = getNextToken();
	    }

	    function getNextToken() {
	        var thisToken = EOF;    // Let's assume that we're at the EOF.
	        if (tokenIndex < tokens.length)
	        {
	            // If we're not at EOF, then return the next token in the stream and advance the index.
	            thisToken = tokens[tokenIndex];
	            putMessage("Current token:" + thisToken);
	            tokenIndex++;
	        }
	        return thisToken;
	    }
    </script>
</body>
</html>